var documenterSearchIndex = {"docs":
[{"location":"01-introduction/#NetworkReduction.jl","page":"NetworkReduction.jl","title":"NetworkReduction.jl","text":"","category":"section"},{"location":"01-introduction/#Overview","page":"NetworkReduction.jl","title":"Overview","text":"NetworkReduction.jl is a high-performance Julia package for physics-preserving reduction and equivalencing of large-scale electrical transmission networks. It provides a mathematically rigorous and computationally efficient workflow for reducing full transmission system models into compact equivalent networks while preserving their power transfer characteristics, congestion behaviour, and operational limits.\n\nThe package is specifically designed for power system studies where full network models are too large or computationally expensive to embed inside:\n\nOptimal Power Flow (OPF)\nUnit Commitment (UC)\nMarket simulation\nAdequacy and planning studies\nLong-term energy system models\n\nIt enables users to replace large meshed networks with accurate reduced equivalents at zonal, regional, national, or continental scale.\n\n","category":"section"},{"location":"01-introduction/#Modelling-Scope","page":"NetworkReduction.jl","title":"Modelling Scope","text":"NetworkReduction.jl implements a DC power flow based network equivalencing framework built on the following modelling principles:\n\nLinearized DC power flow physics\nExact Y-bus matrix formulation\nTopology-preserving Kron reduction\nPTDF-based transfer representation\nTTC-based interzonal capacity preservation\nOptimization-based equivalent line fitting\n\nThe reduced network preserves:\n\nInter-zonal transfer capability\nCongestion behaviour\nElectrical coupling between zones\nPower flow sensitivities\nTransfer bottlenecks\n\nThis allows the reduced network to reproduce the operational behaviour of the original system with orders-of-magnitude lower computational burden.\n\n","category":"section"},{"location":"01-introduction/#What-Problems-Does-It-Solve?","page":"NetworkReduction.jl","title":"What Problems Does It Solve?","text":"Large-scale power system models (ENTSO-E scale, national grids, offshore grids, energy island networks) often contain:\n\nThousands of buses\nTens of thousands of branches\nComplex meshed topologies\n\nEmbedding such models inside optimisation problems leads to:\n\nLong solution times\nMemory bottlenecks\nPoor numerical conditioning\nLimited scalability\n\nNetworkReduction.jl solves this by:\n\nReducing thousands of buses into tens of representative nodes\nPreserving inter-zonal power transfer limits\nMaintaining physical consistency of flows\nProducing compact equivalent networks for fast simulation\n\nThis enables fast, accurate, and scalable power system studies.\n\n","category":"section"},{"location":"01-introduction/#Typical-Use-Cases","page":"NetworkReduction.jl","title":"Typical Use Cases","text":"European transmission system reduction\nNational grid reduction (Ireland, Netherlands, etc.)\nOffshore energy island modelling\nMulti-country interconnection studies\nPower market congestion analysis\nLong-term planning simulations\nEnergy system optimisation models\nAdequacy and security assessment\n\n","category":"section"},{"location":"01-introduction/#Target-Audience","page":"NetworkReduction.jl","title":"Target Audience","text":"This package is intended for:\n\nTransmission system operators (TSOs)\nPower system engineers\nEnergy system researchers\nGrid planning analysts\nPhD students and academics\n\n","category":"section"},{"location":"01-introduction/#Workflow-at-a-glance","page":"NetworkReduction.jl","title":"Workflow at a glance","text":"Load & clean data – Read the raw data, remove invalid entries, assign consistent IDs, and convert everything to per-unit values.\nAnalyse the original grid – Build the Y-bus, compute PTDF matrices for canonical transactions, and derive TTC limits using the original line capacities.\nSelect representative nodes – Group buses by zone/area, then keep the nodes with the highest interconnection degree to serve as the reduced network boundary.\nKron reduction & reduced PTDFs – Eliminate non-representative nodes while preserving admittance relationships, and recompute PTDFs on the reduced system.\nOptimize equivalent capacities – Solve a linear/quadratic/or linearized MIQP program (via JuMP+HiGHS) to find synthetic line capacities that reproduce the canonical TTC limits within tolerance.\nCompare & export – Generate CSV reports (bus maps, TTC comparison, PTDF results, equivalent capacities) so you can inspect or downstream the reduced model.\n\n","category":"section"},{"location":"01-introduction/#Architecture","page":"NetworkReduction.jl","title":"Architecture","text":"The reduction workflow is based on a physics-preserving network equivalencing pipeline: This produces a reduced network that reproduces the transfer behaviour of the original system with minimal error.\n\nflowchart TD\n    A[Full network data import] --> B[Ybus matrix construction]\n    B --> C[Zone definition and representative nodes selection]\n    C --> D[Kron reduction of internal nodes]\n    D --> E[Reduced Ybus Network]\n    E --> F[PTDF computation on original and reduced networks]\n    F --> G[TTC computation]\n    G --> H[Optimisation based equivalent capacities]\n    H --> I[Export results]\n\n\n\n","category":"section"},{"location":"01-introduction/#License","page":"NetworkReduction.jl","title":"License","text":"MIT License\n\n","category":"section"},{"location":"01-introduction/#Citation","page":"NetworkReduction.jl","title":"Citation","text":"If you use this package in academic work, please cite:\n\nNetworkReduction.jl – A Julia Toolkit for Power System Network Reduction and Equivalencing","category":"section"},{"location":"03-model-usage/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"03-model-usage/#From-gitHub-repository","page":"Installation","title":"From gitHub repository","text":"using Pkg\nPkg.add(url=\"https://github.com/TulipaEnergy/NetworkReduction.jl.git\")\nPkg.instantiate()","category":"section"},{"location":"03-model-usage/#Local-development-installation","page":"Installation","title":"Local development installation","text":"# Clone the repository\ngit clone https://github.com/TulipaEnergy/NetworkReduction.jl.git\ncd NetworkReduction.jl\n\n# Start Julia and activate project\njulia --project=@.\n\n# Instantiate dependencies\nusing Pkg\nPkg.instantiate()","category":"section"},{"location":"03-model-usage/#Basic-usage","page":"Installation","title":"Basic usage","text":"using NetworkReduction\n\n# Define input/output directories\ninput_dir = \"test/inputs/NL_case\"    # Contains your Excel network data\n\noutput_dir = \"test/outputs/NL_case\"  # Where results will be saved\n\n# Run the complete analysis\nresults = main_full_analysis(input_dir, output_dir)","category":"section"},{"location":"03-model-usage/#How-to-run-a-case-study","page":"Installation","title":"How to run a case study","text":"Prepare Data: Place your network Excel file (containing 'Lines', 'Tielines', 'Nodes', and 'Generators' sheets) in the inputs/ folder.\nSet Configuration: Ensure config.jl points to your filename and preferred optimization type. All parameters are centralized in config.jl:\n\nCONFIG.input_filename = \"case118.xlsx\"       # Input Excel file name\nCONFIG.case_study = \"case118\"                # Case study identifier\nCONFIG.bus_names_as_int = false              # Bus names are strings/integers (true for integers, false for strings)\nCONFIG.in_pu = false                         # Line parameters are in ohms/per-unit (true for per-unit, fasle for ohms)\nCONFIG.base = 100.0                          # MVA base for per-unit conversion\nCONFIG.optimization_type = \"QP\"              # Optimization type used for equivalent capcaites \"MIQP\", \"QP\", or \"LP\"\nCONFIG.lambda = 1e-6                         # Regularization parameter\nCONFIG.ptdf_epsilon = 0.001                  # PTDF zero threshold\nCONFIG.suffix = \"QP\"                         # Output file suffix\n\nExecute: Run the main_full_analysis function.\nReview Results: Check the outputs/ folder for:\n\n| File                         | Description                   |\n| ---------------------------- | ----------------------------- |\n| Bus_ID_Map_QP.csv            | Mapping of bus names to IDs   |\n| Line_Details_QP.csv          | Detailed line parameters      |\n| Representative_Nodes_QP.csv  | Selected representative nodes |\n| TTC_Original_Network_QP.csv  | Original TTCs                 |\n| PTDF_Reduced_Network_QP.csv  | Reduced PTDFs                 |\n| Equivalent_Capacities_QP.csv | Synthetic line capacities     |\n| TTC_Comparison_QP.csv        | TTC validation                |","category":"section"},{"location":"03-model-usage/#Advanced:-Interpreting-Results","page":"Installation","title":"Advanced: Interpreting Results","text":"If the optimization fails to converge, consider:\n\nChecking Connectivity: Ensure all representative nodes are electrically connected in the original network.\nAdjusting Lambda: Increase lambda in CONFIG if synthetic capacities are fluctuating significantly.\nBig-M Factor: For \"MIQP\" (MILP), adjust the bigM_factor if binding constraints are not being identified correctly[cite: 89, 93].","category":"section"},{"location":"05-api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"05-api/#NetworkReduction._solve_miqp_model-Tuple{Vector{Float64}, Vector{Tuple{Int64, Int64}}, UnitRange{Int64}, UnitRange{Int64}, Dict{Tuple{Int64, Int64}, Float64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}}","page":"API Reference","title":"NetworkReduction._solve_miqp_model","text":"Linearized MILP formulation using HiGHS that enforces exactly one binding line per transaction. Objective: minimize sum of absolute TTC errors (L1 norm).\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.calculate_all_ptdfs_original-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64}, DataFrames.DataFrame, DataFrames.DataFrame}","page":"API Reference","title":"NetworkReduction.calculate_all_ptdfs_original","text":"calculate_all_ptdfs_original(Ybus, lines_df, tie_lines_df)\n\nCalculate PTDFs for all canonical transactions (A->B where A < B) in the original network. Optimized version using matrix method for massive speedup.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.calculate_ptdfs_dc_power_flow","page":"API Reference","title":"NetworkReduction.calculate_ptdfs_dc_power_flow","text":"calculate_ptdfs_dc_power_flow(Ybus, from_bus, to_bus)\n\nCalculate PTDF matrix for a specific transaction using DC power flow approximation. Optimized version using matrix method for single reference slack.\n\n\n\n\n\n","category":"function"},{"location":"05-api/#NetworkReduction.calculate_ptdfs_reduced-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64}, Vector{Int64}}","page":"API Reference","title":"NetworkReduction.calculate_ptdfs_reduced","text":"calculate_ptdfs_reduced(Y_kron, rep_node_ids)\n\nCalculate PTDFs for canonical transactions between representative nodes using Kron-reduced matrix. Optimized version using matrix method.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.calculate_single_injection_ptdfs","page":"API Reference","title":"NetworkReduction.calculate_single_injection_ptdfs","text":"calculate_single_injection_ptdfs(Ybus, reference_bus)\n\nCalculate PTDFs for single unit injections at each bus relative to reference bus. Returns Dict of PTDF vectors for each bus injection.\n\n\n\n\n\n","category":"function"},{"location":"05-api/#NetworkReduction.calculate_ttc_from_ptdfs-Tuple{DataFrames.DataFrame, Dict{Tuple{Int64, Int64}, Float64}}","page":"API Reference","title":"NetworkReduction.calculate_ttc_from_ptdfs","text":"calculate_ttc_from_ptdfs(ptdf_df, line_capacities)\n\nCalculate the Total Transfer Capacity (TTC) for every canonical transaction (A < B). Returns DataFrame with TTC values and limiting line information.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.clean_line_data-Tuple{DataFrames.DataFrame}","page":"API Reference","title":"NetworkReduction.clean_line_data","text":"clean_line_data(lines_df::DataFrame)\n\nClean line data by removing self-loops and assigning fake EIC codes to missing entries.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.convert_line_to_pu!-Tuple{DataFrames.DataFrame, Float64}","page":"API Reference","title":"NetworkReduction.convert_line_to_pu!","text":"convert_line_to_pu!(lines_df::DataFrame, Sbase::Float64; in_pu::Bool=false)\n\nConvert line parameters to per-unit values based on system base power. If in_pu is true, assumes R, X, B are already in per-unit and only converts capacity.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.create_ttc_results_from_optimization-Tuple{Vector{Float64}, DataFrames.DataFrame}","page":"API Reference","title":"NetworkReduction.create_ttc_results_from_optimization","text":"create_ttc_results_from_optimization(\nttc_vals::Vector{Float64},\nttc_canonical::DataFrame;\nmodel=model,\nType = CONFIG.optimization_type,\nsynth_lines::Vector{Tuple{Int,Int}} = Tuple{Int,Int}[],\nbinding_dict::Union{Dict,Nothing} = nothing\n)\n\nCreate TTC results directly from optimization variables.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.export_bus_id_map-Tuple{DataFrames.DataFrame, String}","page":"API Reference","title":"NetworkReduction.export_bus_id_map","text":"export_bus_id_map(node_info, export_path)\n\nExport a CSV file containing the mapping between old bus names and new numerical IDs.\n\nArguments\n\nnode_info::DataFrame: Node information with oldname and newid columns\nexport_path::String: Path where the CSV file will be saved\n\nOutput CSV Format\n\nold_name: Original bus names from input data\nnew_id: Numerical IDs assigned during processing\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.export_detailed_line_info-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, String}","page":"API Reference","title":"NetworkReduction.export_detailed_line_info","text":"export_detailed_line_info(lines_df, tielines_df, export_path)\n\nExport comprehensive line information including both original names and numerical IDs.\n\nArguments\n\nlines_df::DataFrame: Regular transmission lines data\ntielines_df::DataFrame: Tie lines data\nexport_path::String: Path where the CSV file will be saved\n\nOutput CSV Columns\n\nEIC_Code: European Identification Code for the line\nFromnode, Tonode: Original bus names\nNewIDFrom, NewIDTo: Numerical bus IDs\nVoltage_level: Operating voltage level\nLength_km: Line length in kilometers\nCapacityMW, Capacitypu: Line capacity in MW and per-unit\nRpu, Xpu, B_pu: Line parameters in per-unit\nIsTieLine: Boolean flag indicating if this is a tie line\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.form_ybus_with_shunt-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, Float64}","page":"API Reference","title":"NetworkReduction.form_ybus_with_shunt","text":"form_ybus_with_shunt(lines_df, tie_lines_df, node_info, Sbase)\n\nForm the network admittance matrix (Y-bus) including shunt elements. Returns a sparse complex matrix representing the network admittance.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.kron_reduce_ybus-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64}, Vector{Int64}}","page":"API Reference","title":"NetworkReduction.kron_reduce_ybus","text":"kron_reduce_ybus(Ybus, rep_node_ids)\n\nPerform Kron reduction on the original Ybus matrix to eliminate non-representative nodes.\n\nThe Kron reduction technique eliminates internal nodes while preserving the electrical relationships between the representative nodes. This creates an equivalent network with fewer nodes but equivalent transfer characteristics.\n\nArguments\n\nYbus::SparseMatrixCSC{ComplexF64}: Original network admittance matrix\nrep_node_ids::Vector{Int}: Indices of representative nodes to retain\n\nReturns\n\nY_kron::SparseMatrixCSC{ComplexF64}: Reduced admittance matrix\n\nMathematical Background\n\nThe Kron reduction partitions the admittance matrix as:\n\nY = [K   L_T]\n    [L   M  ]\n\nwhere K connects representative nodes, M connects eliminated nodes, and L connects representative to eliminated nodes.\n\nThe reduced matrix is: Ykron = K - LT * M^(-1) * L\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.load_excel_data-Tuple{String}","page":"API Reference","title":"NetworkReduction.load_excel_data","text":"load_excel_data(file_path::String)\n\nLoad network data from Excel file with multiple sheets. Returns a dictionary containing DataFrames for lines, tielines, nodes, and generators.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.main_full_analysis-Tuple{String, String}","page":"API Reference","title":"NetworkReduction.main_full_analysis","text":"main_full_analysis()\n\nComplete network reduction analysis workflow including:\n\nData loading and preprocessing\nOriginal network PTDF/TTC analysis\nRepresentative node selection\nKron reduction\nReduced network analysis\nOptimization of equivalent capacities\nResults comparison and export\n\nReturns\n\nTuple containing:\n\nttc_results: Original network TTC calculations\nptdfreducedresults: Reduced network PTDF calculations\nequivalentcapacitiesdf: Optimized equivalent capacities\n\nData Directory\n\nModify the inputdatadir and outputdatadir variables to change the location.\n\nOutput Files\n\nBusIDMap_QP.csv: Mapping of bus names to numerical IDs\nLineDetailsQP.csv: Comprehensive line information\nRepresentativeNodesQP.csv: Selected representative nodes\nTTCOriginalNetwork_QP.csv: Original network TTC values\nPTDFReducedNetwork_QP.csv: Reduced network PTDF values\nEquivalentCapacitiesQP.csv: Optimized synthetic line capacities\nTTCComparisonQP.csv: Comparison of original vs equivalent TTC values\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.process_tielines-Tuple{DataFrames.DataFrame}","page":"API Reference","title":"NetworkReduction.process_tielines","text":"process_tielines(tielines_df::DataFrame)\n\nProcess tie-lines by sorting, removing duplicates, and handling missing EIC codes.\n\n\n\n\n\n","category":"method"},{"location":"05-api/#NetworkReduction.rename_buses","page":"API Reference","title":"NetworkReduction.rename_buses","text":"rename_buses(nodes_df, generators_df, lines_df, tie_lines_df, Sbase)\n\nRename buses to uppercase, create numerical mapping, and convert data to per-unit. Returns processed line DataFrames and node information.\n\n\n\n\n\n","category":"function"},{"location":"05-api/#NetworkReduction.select_representative_nodes-Tuple{SparseArrays.SparseMatrixCSC{ComplexF64}, DataFrames.DataFrame}","page":"API Reference","title":"NetworkReduction.select_representative_nodes","text":"select_representative_nodes(Ybus, node_info)\n\nSelect a single representative node (RN) from each unique 'Zone' based on the highest interconnection degree.\n\nArguments\n\nYbus::SparseMatrixCSC{ComplexF64}: Network admittance matrix\nnode_info::DataFrame: Node information DataFrame\n\nReturns\n\nrep_nodes::DataFrame: DataFrame with selected representative nodes\nnode_info::DataFrame: Updated nodeinfo with isrepresentative flag set\n\n\n\n\n\n","category":"method"},{"location":"02-mathematical-formulation/#Mathematical-Formulation","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"This document presents the mathematical foundations of the NetworkReduction.jl model. The objective of the model is to construct a reduced electrical network that preserves the power transfer characteristics of the original system while significantly reducing its size.\n\n","category":"section"},{"location":"02-mathematical-formulation/#1.-Network-Admittance-Matrix-(Y_{bus})","page":"Mathematical Formulation","title":"1. Network Admittance Matrix (Y_bus)","text":"The electrical network is represented by its nodal admittance matrix:\n\nY = G + jB\n\nwhere:\n\nG\nis the conductance matrix.\nB\nis the susceptance matrix.\nj = sqrt-1\n.\n\nEach transmission line between buses i and j is modeled by its series admittance y_ij = frac1R_ij + jX_ij. Including shunt susceptance B_ij, the Y_bus is assembled as:\n\nDiagonal elements: Y_ii = sum_j in mathcalN(i) left( y_ij + jfracB_ij2 right) + (G_i^shunt + jB_i^shunt)\nOff-diagonal elements: Y_ij = -y_ij\n\n","category":"section"},{"location":"02-mathematical-formulation/#2.-DC-Power-Flow-and-PTDFs","page":"Mathematical Formulation","title":"2. DC Power Flow and PTDFs","text":"Under the DC approximation (negligible resistance, flat voltage magnitudes, small angles), active power flow is:\n\nP = B theta","category":"section"},{"location":"02-mathematical-formulation/#2.1-Power-Transfer-Distribution-Factors-(PTDF)","page":"Mathematical Formulation","title":"2.1 Power Transfer Distribution Factors (PTDF)","text":"The PTDF for a line l (from bus i to j) during a transaction between buses a and b is:\n\nPTDF_l^a to b = b_ij (theta_i^a to b - theta_j^a to b)\n\nIn the code, this is solved by calculating the sensitivity of bus angles to injections at buses a and b relative to a slack bus.\n\n","category":"section"},{"location":"02-mathematical-formulation/#3.-Total-Transfer-Capacity-(TTC)","page":"Mathematical Formulation","title":"3. Total Transfer Capacity (TTC)","text":"The TTC for a transaction t (from a to b) is the maximum power flow possible before any line hits its thermal limit C_l:\n\nTTC_t = min_l in textLines left( fracC_lPTDF_tl right)\n\n","category":"section"},{"location":"02-mathematical-formulation/#4.-Network-Reduction-(Kron)","page":"Mathematical Formulation","title":"4. Network Reduction (Kron)","text":"The system is partitioned into Representative Nodes (R) and Eliminated Nodes (E):\n\nY = beginbmatrix Y_RR  Y_RE  Y_ER  Y_EE endbmatrix\n\nThe reduced admittance matrix Y_reduced (Kron Reduction) is:\n\nY_reduced = Y_RR - Y_RE Y_EE^-1 Y_ER\n\n","category":"section"},{"location":"02-mathematical-formulation/#5.-Optimization-of-Equivalent-Capacities","page":"Mathematical Formulation","title":"5. Optimization of Equivalent Capacities","text":"The package identifies synthetic capacities C_l^eq for the reduced network to match the original TTC^orig. Based on optimization.jl, three methods are available:","category":"section"},{"location":"02-mathematical-formulation/#5.1-Quadratic-Programming-(QP)","page":"Mathematical Formulation","title":"5.1 Quadratic Programming (QP)","text":"Objective: Minimize the squared error between original and equivalent TTC, with a regularization term to keep capacities realistic.\n\nmin sum_t in mathcalT (TTC_t^eq - TTC_t^orig)^2 + lambda sum_l in mathcalL_red (C_l^eq)^2\n\nConstraints:\n\nFlow Limit: For every transaction t and every synthetic line l: TTC_t^eq cdot PTDF_tl le C_l^eq quad forall t forall l\nNon-negativity: C_l^eq ge 0 quad TTC_t^eq ge 0","category":"section"},{"location":"02-mathematical-formulation/#5.2-Linear-Programming-(LP)","page":"Mathematical Formulation","title":"5.2 Linear Programming (LP)","text":"Objective: Maximize the total transfer capacity of the reduced network while ensuring it never exceeds the original limits.\n\nmax sum_t in mathcalT TTC_t^eq\n\nConstraints:\n\nUpper Bound: TTC_t^eq le TTC_t^orig quad forall t\nPhysical Limit: TTC_t^eq cdot PTDF_tl le C_l^eq quad forall t forall l\nCapacity Ceiling: (Optional scaling) C_l^eq le textmax_factor cdot max(TTC^orig)","category":"section"},{"location":"02-mathematical-formulation/#7.2-MIQP-(Original-Mixed-Integer-Quadratic-Programming)","page":"Mathematical Formulation","title":"7.2 MIQP (Original Mixed-Integer Quadratic Programming)","text":"This formulation is used when we want to identify which synthetic line is binding (limiting) for each transaction.","category":"section"},{"location":"02-mathematical-formulation/#Decision-Variables","page":"Mathematical Formulation","title":"Decision Variables","text":"C_l^eq ge 0\n: synthetic line capacities\nTTC_t^eq ge 0\n: equivalent TTC values\nz_tl in 01\n: binding indicator (z_tl = 1 means line l limits transaction t)","category":"section"},{"location":"02-mathematical-formulation/#Objective","page":"Mathematical Formulation","title":"Objective","text":"min sum_tinmathcalT (TTC_t^eq-TTC_t^orig)^2 + lambdasum_linmathcalL (C_l^eq)^2","category":"section"},{"location":"02-mathematical-formulation/#Constraints","page":"Mathematical Formulation","title":"Constraints","text":"General physical TTC upper bound: TTC_t^eq le fracC_l^eqPTDF_tlqquad forall tl\nExactly one binding line per transaction: sum_linmathcalL z_tl = 1 qquad forall t\nBig-M binding constraint (enforcing equality on chosen line): fracC_l^eqPTDF_tl - TTC_t^eq le M(1-z_tl) qquad forall tl\n\n","category":"section"},{"location":"02-mathematical-formulation/#7.3-Linearized-MIQP-MILP-(HiGHS-Compatible)","page":"Mathematical Formulation","title":"7.3 Linearized MIQP → MILP (HiGHS-Compatible)","text":"To make the MIQP practical for large networks, the implementation uses a linearized MILP solved by HiGHS.","category":"section"},{"location":"02-mathematical-formulation/#Decision-Variables-(MILP)","page":"Mathematical Formulation","title":"Decision Variables (MILP)","text":"C_l^eq ge 0\n: synthetic line capacity\nTTC_t^eq ge 0\n: equivalent TTC\nb_tlin01\n: binding selection\nZ_tlge 0\n: allocated capacity for transaction t on line l\nV_t^absge 0\n: absolute TTC error (L1 linearization)","category":"section"},{"location":"02-mathematical-formulation/#Objective-(L1-TTC-matching)","page":"Mathematical Formulation","title":"Objective (L1 TTC matching)","text":"min sum_tinmathcalT V_t^abs\n\nLinearization of absolute value: V_t^abs ge TTC_t^eq-TTC_t^orig qquad forall t V_t^abs ge TTC_t^orig-TTC_t^eq qquad forall t","category":"section"},{"location":"02-mathematical-formulation/#MILP-Constraints","page":"Mathematical Formulation","title":"MILP Constraints","text":"","category":"section"},{"location":"02-mathematical-formulation/#A)-TTC-definition-using-allocated-capacity-Z","page":"Mathematical Formulation","title":"A) TTC definition using allocated capacity Z","text":"TTC_t^eq = sum_linmathcalL_t fracZ_tlPTDF_tl qquad forall t","category":"section"},{"location":"02-mathematical-formulation/#B)-Capacity-allocation-limits","page":"Mathematical Formulation","title":"B) Capacity allocation limits","text":"Z_tl le C_l^eqqquad forall tl","category":"section"},{"location":"02-mathematical-formulation/#C)-Exactly-one-binding-line-per-transaction","page":"Mathematical Formulation","title":"C) Exactly one binding line per transaction","text":"sum_linmathcalL_t b_tl = 1qquad forall t","category":"section"},{"location":"02-mathematical-formulation/#D)-Big-M-logic","page":"Mathematical Formulation","title":"D) Big-M logic","text":"if b_tl=1, then Z_tl=C_l^eq\nif b_tl=0, then Z_tl=0\n\nZ_tl le M_Z b_tlqquad forall tl\n\nZ_tl ge C_l^eq - M_Z(1-b_tl)qquad forall tl","category":"section"},{"location":"02-mathematical-formulation/#E)-Numerical-stability-bounds","page":"Mathematical Formulation","title":"E) Numerical stability bounds","text":"TTC_t^eq le M_TTCqquad forall t","category":"section"},{"location":"02-mathematical-formulation/#Important-Implementation-Notes","page":"Mathematical Formulation","title":"Important Implementation Notes","text":"PTDF Epsilon: The optimization ignores lines where PTDF  epsilon (defined in config.jl) to avoid numerical instability (division by zero).\nMW Conversion: While the optimization typically occurs in per-unit (p.u.), the main-analysis.jl script converts final C_l^eq results to MW using the Sbase defined in CONFIG.\nRegularization (lambda): The lambda parameter is crucial. Without it, the solver may assign infinitely high capacities to lines that don't participate in any binding constraints. A small lambda (e.g., 10^-6) ensures the smallest sufficient capacity is chosen.","category":"section"},{"location":"#NetworkReduction.jl","page":"NetworkReduction.jl","title":"NetworkReduction.jl","text":"NetworkReduction.jl is a Julia toolkit for network equivalencing and reduction (Kron-based reduction, PTDF/TTC workflows, and capacity optimization).","category":"section"},{"location":"#Contents","page":"NetworkReduction.jl","title":"Contents","text":"Use the navigation on the left to read:\n\nIntroduction\nMathematical formulation\nModel usage","category":"section"}]
}
